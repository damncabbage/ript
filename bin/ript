#!/usr/bin/env ruby

require 'pathname'
$: << Pathname.new(__FILE__).parent.parent.join('lib').expand_path.to_s
# so rules/ can be loaded
$: << Pathname.new(__FILE__).parent.parent.expand_path.to_s
$: << Dir.pwd
require 'ript/dsl'
require 'ript/cli'
require 'tempfile'

if Process.uid != 0 then
  puts "You must run this as root!"
  exit 1
end

if not ARGV[0]
  puts "Usage: #{$0} <rulefile|directory>"
  exit! 1
end

if ARGV[0] == 'rules'
  if ARGV[1] == "generate" or ARGV[1] == "diff" then

    begin
      Ript::CLI.load_rules_from_path(ARGV.fetch(2))
    rescue LoadError => e
      puts e.message
      exit 160
    end

    if `iptables --list partition-a --numeric 2>&1 | grep Chain` !~ /^Chain/
      require 'ript/bootstrap'
      puts "# bootstrap"
      puts Ript::Bootstrap.partition.to_iptables
    end

    if ARGV[1] == "generate"
      self.partitions.each do |partition|
        puts "# #{partition.name}-#{partition.id}"
        puts partition.to_iptables
      end
    end

    if ARGV[1] == "diff"
      self.partitions.each do |partition|
        # We assume here that if a partition has a partition-a chain it will have all the others
        chain_name = "#{partition.name}-#{partition.id.split('-').first}".sub(/-/, '-a')
        chains = Ript::Iptables.current_chain_names_by_partition[:a]
        unless chains.has_key?(partition.name) && chains[partition.name].include?(chain_name)
          puts "# #{partition.name}-#{partition.id}"
          puts partition.to_iptables
        end
      end
    end

    exit
  end

  if ARGV[1] == "apply" then
    output   = `#{$0} rules diff #{ARGV[2..-1].join(' ')} 2>&1`
    tempfile = Tempfile.open("ript-apply-#{Time.now.to_i}") {|f| f << output}
    puts "#{output}"
    system("sh -e #{tempfile.path}")
    exit
  end

  if ARGV[1] == 'flush' then
    output = <<-EOF
  iptables --flush --table filter
  iptables --delete-chain --table filter
  iptables --table filter --policy INPUT ACCEPT
  iptables --table filter --policy FORWARD ACCEPT
  iptables --table filter --policy OUTPUT ACCEPT

  # Clean NAT
  iptables --flush --table nat
  iptables --delete-chain --table nat
  iptables --table nat --policy PREROUTING ACCEPT
  iptables --table nat --policy POSTROUTING ACCEPT
  iptables --table nat --policy OUTPUT ACCEPT

  # Clean mangle
  iptables --flush --table mangle
  iptables --delete-chain --table mangle
  iptables --table mangle --policy PREROUTING ACCEPT
  iptables --table mangle --policy POSTROUTING ACCEPT
  iptables --table mangle --policy INPUT ACCEPT
  iptables --table mangle --policy FORWARD ACCEPT
  iptables --table mangle --policy OUTPUT ACCEPT
    EOF
    tempfile = Tempfile.open("ript-apply-#{Time.now.to_i}") {|f| f << output}
    puts "#{output}"
    system("sh -e #{tempfile.path}")
    exit
  end

  if ARGV[1] == 'save' then
    system('/sbin/iptables-save')
    exit
  end

  puts "Usage: #{$0} <rules> <generate|diff|apply|save> <rulefile|directory>"
  exit! 1
end

if ARGV[0] == "clean" then
  if ARGV[1] == "diff" then
    path = Pathname.new(ARGV[2])

    case
    when path.directory?
      path = (path + "**/*.rb").to_s
      files = Pathname.glob(path)
      files.each do |file|
        require "#{file}"
      end
    when path.exist?
      begin
        require "#{path}"
      rescue LoadError => e
        puts e
        puts "The specified rule file '#{path}' does not exist"
        exit 160
      end
    else
      puts "The specified rule file or directory '#{path}' does not exist"
      exit 160
    end

    Ript::Iptables.current_chain_names_by_partition.each_pair do |type, partition_chains|
      partition_chains.each_pair do |partition, chains|
        # If we are in file mode don't remove other partitions
        next if File.file?(path) && ! self.partitions.map(&:name).include?(partition)
        partition_obj = self.partitions.find {|c| c.name == partition }
        unless partition_obj.nil?
          chain_name = "#{partition_obj.name}-#{type}#{partition_obj.id.split('-').first}"
          chains = chains - [chain_name]
        end

        chains.uniq.each do |chain|
          table = Ript::Iptables.partition_types[type]

          clean_command = `iptables-save --table #{table} 2>&1 | grep -- '-A partition-#{type}' | grep -- '-j #{chain}'`.split("\n")
          clean_command.map! {|line| "iptables --table #{table} #{line}" }
          clean_command.map! {|line| line.gsub(" -A", " --delete") }
          clean_command.map! {|line| line.gsub(" -s", " --source") }
          clean_command.map! {|line| line.gsub(" -d", " --destination") }
          clean_command.map! {|line| line.gsub(" -j", " --jump") }
          clean_command.map! {|line| line.strip }
          puts clean_command

          puts "iptables --table #{table} --flush #{chain}"
          puts "iptables --table #{table} --delete-chain #{chain}"

        end
      end
    end
    exit
  end

  if ARGV[1] == "apply" then
    output = `#{$0} clean diff #{ARGV[2..-1].join(' ')} 2>&1`
    puts "#{output}"
    system("bash -c '#{output}'")

    exit
  end

  puts "Usage: #{$0} <clean> <diff|apply> <rulefile|directory>"
  exit! 1
end


puts "Usage: #{$0} <rules|clean|save> <generate|diff|apply> <rulefile|directory>"
exit! 1
