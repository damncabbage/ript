#!/usr/bin/env ruby

require 'pathname'
$: << Pathname.new(__FILE__).parent.parent.join('lib').expand_path.to_s
# so rules/ can be loaded
$: << Pathname.new(__FILE__).parent.parent.expand_path.to_s
$: << Dir.pwd
require 'ript/dsl'
require 'tempfile'

require 'gli'
include GLI::App

program_desc "provides a clean Ruby DSL for describing firewall rules, and implements database migrations-like functionality for applying the rules."

if RUBY_VERSION =~ /^1.8/ then
  puts "Ript requires Ruby 1.9 to run. Exiting."
  exit
end

desc "Commands to generate, apply, diff and save rules. See: ript help rules"
command :rules do |t|
  t.desc "Outputs all the generated rules by interpreting the file, or files in directory, <path>"
  t.arg_name "<path>"
  t.command :generate do |c|
    c.action do |gopts, opts, args|
    end
  end

  t.desc "Outputs a diff of rules to apply based on what rules are currently loaded in memory compared with the rules generated by <path>."
  t.arg_name "<path>"
  t.command :diff do |c|
    c.action do |gopts, opts, args|
    end
  end

  t.desc "Applies the aforementioned diff."
  t.arg_name "<path>"
  t.command :apply do |c|
    c.action do |gopts, opts, args|
    end
  end

  # TODO: Undocumented in README; is this a "public" command, or only for Ript's internal use?
  t.desc "Cleans out all the firewall rules that have been applied."
  t.command :flush do |c|
    c.action do |gopts, opts, args|
    end
  end

  t.desc "Outputs the currently-loaded rules in iptables-restore format."
  t.command :save do |c|
    c.action do |gopts, opts, args|
    end
  end
end

desc "Commands to clean out old rules. See: ript help clean"
command :clean do |t|
  t.desc "Compares and currently-applied rules with those generated by <path>, and outputs iptables commands to delete unneeded entries."
  t.arg_name "<path>"
  t.command :diff do |c|
    c.action do |gopts, opts, args|
    end
  end

  t.desc "Applies the aforementioned diff"
  t.arg_name "<path>"
  t.command :apply do |c|
    c.action do |gopts, opts, args|
    end
  end
end

# Helpers
require_root!
def require_root!
  unless Process.uid > 0
    puts "You must run this as root!"
    exit 1
  end
end

def types
  {
    :a => 'filter',
    :d => 'nat',
    :s => 'nat',
  }
end

def current_chain_names_by_partition
  # Collect the full iptables output
  output = {}
  types.each_pair do |type, table|
    output[type] =  `iptables --table #{table} --list partition-#{type} --numeric 2>&1 | grep -v 'No chain/target/match by that name'`.split("\n")
  end

  blacklist  = %w(PREROUTING POSTROUTING OUTPUT INPUT FORWARD Chain target before-a after-a partition-a partition-d partition-s)
  chains = {}

  types.keys.each do |type|
    chains[type] = {}
    output[type].each do |line|
      chain_name = line.split(/ /).first
      next if blacklist.include? chain_name
      partition = chain_name.split(/-/).first
      chains[type][partition] ||= []
      chains[type][partition] << chain_name
    end
  end

  # Add the chains that aren't referenced anywhere to the end
  ['nat', 'filter'].each do |table|
    unlisted = `iptables --table #{table} --list --numeric 2>&1 | grep 'Chain'`.split("\n")
    unlisted = unlisted.map {|l| l.split(/ /)[1]} - blacklist
    unlisted.each do |chain_name|
      partition, type = chain_name.split(/-/)
      type = type[0].to_sym
      chains[type][partition] ||= []
      unless chains[type][partition].include? chain_name
        chains[type][partition] << chain_name
      end
    end
  end
  chains
end

exit run(ARGV)

if ARGV[0] == 'rules'
  if ARGV[1] == "generate" or ARGV[1] == "diff" then
    begin
      Ript::CLI.load_rules_from_path(ARGV[2])
    rescue Ript::CLI::RulesNotFoundError => e
      puts e.message
      exit 160
    end

    if Ript::CLI.requires_bootstrap?
      puts Ript::CLI.bootstrap
    end

    if ARGV[1] == "generate"
      @partitions.each do |partition|
        puts "# #{partition.name}-#{partition.id}"
        puts partition.to_iptables
      end
    end

    if ARGV[1] == "diff"
      require_root!
      @partitions.each do |partition|
        # We assume here that if a partition has a partition-a chain it will have all the others
        chain_name = "#{partition.name}-#{partition.id.split('-').first}".sub(/-/, '-a')
        unless current_chain_names_by_partition[:a].has_key?(partition.name) && current_chain_names_by_partition[:a][partition.name].include?(chain_name)
          puts "# #{partition.name}-#{partition.id}"
          puts partition.to_iptables
        end
      end
    end

    exit
  end

  if ARGV[1] == "apply" then
    output   = `#{$0} rules diff #{ARGV[2..-1].join(' ')} 2>&1`
    tempfile = Tempfile.open("ript-apply-#{Time.now.to_i}") {|f| f << output}
    puts "#{output}"
    system("sh -e #{tempfile.path}")
    exit
  end

  if ARGV[1] == 'flush' then
    output = <<-EOF
  iptables --flush --table filter
  iptables --delete-chain --table filter
  iptables --table filter --policy INPUT ACCEPT
  iptables --table filter --policy FORWARD ACCEPT
  iptables --table filter --policy OUTPUT ACCEPT

  # Clean NAT
  iptables --flush --table nat
  iptables --delete-chain --table nat
  iptables --table nat --policy PREROUTING ACCEPT
  iptables --table nat --policy POSTROUTING ACCEPT
  iptables --table nat --policy OUTPUT ACCEPT

  # Clean mangle
  iptables --flush --table mangle
  iptables --delete-chain --table mangle
  iptables --table mangle --policy PREROUTING ACCEPT
  iptables --table mangle --policy POSTROUTING ACCEPT
  iptables --table mangle --policy INPUT ACCEPT
  iptables --table mangle --policy FORWARD ACCEPT
  iptables --table mangle --policy OUTPUT ACCEPT
    EOF
    tempfile = Tempfile.open("ript-apply-#{Time.now.to_i}") {|f| f << output}
    puts "#{output}"
    system("sh -e #{tempfile.path}")
    exit
  end

  if ARGV[1] == 'save' then
    system('/sbin/iptables-save')
    exit
  end

  puts "Usage: #{$0} <rules> <generate|diff|apply|save> <rulefile|directory>"
  exit! 1
end

if ARGV[0] == "clean" then
  require_root!
  if ARGV[1] == "diff" then
    path = Pathname.new(ARGV[2])

    case
    when path.directory?
      path = (path + "**/*.rb").to_s
      files = Pathname.glob(path)
      files.each do |file|
        require "#{file}"
      end
    when path.exist?
      begin
        require "#{path}"
      rescue LoadError => e
        puts e
        puts "The specified rule file '#{path}' does not exist"
        exit 160
      end
    else
      puts "The specified rule file or directory '#{path}' does not exist"
      exit 160
    end

    current_chain_names_by_partition.each_pair do |type, partitions|
      partitions.each_pair do |partition, chains|
        # If we are in file mode don't remove other partitions
        next if File.file?(path) && ! @partitions.map(&:name).include?(partition)
        partition_obj = @partitions.find {|c| c.name == partition }
        unless partition_obj.nil?
          chain_name = "#{partition_obj.name}-#{type}#{partition_obj.id.split('-').first}"
          chains = chains - [chain_name]
        end

        chains.uniq.each do |chain|
          table = types[type]

          clean_command = `iptables-save --table #{table} 2>&1 | grep -- '-A partition-#{type}' | grep -- '-j #{chain}'`.split("\n")
          clean_command.map! {|line| "iptables --table #{table} #{line}" }
          clean_command.map! {|line| line.gsub(" -A", " --delete") }
          clean_command.map! {|line| line.gsub(" -s", " --source") }
          clean_command.map! {|line| line.gsub(" -d", " --destination") }
          clean_command.map! {|line| line.gsub(" -j", " --jump") }
          clean_command.map! {|line| line.strip }
          puts clean_command

          puts "iptables --table #{table} --flush #{chain}"
          puts "iptables --table #{table} --delete-chain #{chain}"

        end
      end
    end
    exit
  end

  if ARGV[1] == "apply" then
    output = `#{$0} clean diff #{ARGV[2..-1].join(' ')} 2>&1`
    puts "#{output}"
    system("bash -c '#{output}'")

    exit
  end

  puts "Usage: #{$0} <clean> <diff|apply> <rulefile|directory>"
  exit! 1
end


puts "Usage: #{$0} <rules|clean|save> <generate|diff|apply> <rulefile|directory>"
exit! 1
